#!/usr/bin/env bash

set -e

script_path="$( cd -P "$( dirname "$(readlink -f "${0}")" )" && pwd )"
work_dir="${script_path}/work"
debug=false
remove=false
notar=false
skiplist=()

echo_stderr(){
    echo -e "${@}" >&2
}

msg_debug(){
    if [[ "${debug}" = true ]]; then
        echo_stderr "DEBUG  : ${*}"
    fi
}

msg_error(){
    echo_stderr "ERROR  : ${1}"
    if [[ -n "${2:-}" ]]; then
        exit "${2}"
    fi
}

msg_warn(){
    echo_stderr "WARNING: ${*}"
}

msg_info(){
    echo_stderr "INFO   : ${*}"
}

_usage(){
    echo "usage ${0} [options] [deb file]"
    echo
    echo "Convet deb file to pacman file"
    echo
    echo " General options:"
    echo "    -d | --debug                 Enable debug message"
    echo "    -w | --work <work_dir>       Set the working directory"
    echo "    -h | --help                  Show this help message"
    echo "         --notar                 No unarchive deb file"
    echo "         --remove                Remove work dir"
    echo "         --skip <var1,var2>      Value to skip setting (multiple can be specified)"
}

Run(){
    msg_info "Start ${1}"
    eval "${@}"
}

CheckEnv(){
    if (( UID == 0 )); then
        msg_error "Do not run as root" 1
    fi

    if [[ ! -f "${debfile}" ]]; then
        msg_error "${debfile} was not found" 1
    fi

    if ! test "$(file --mime-type "${debfile}" | cut -d " " -f 2 | cut -d "/" -f 2)" = "vnd.debian.binary-package"; then
        msg_error "${debfile} is not debian package" 1
    fi
}

RemoveWork(){
    msg_info "Removing ${work_dir}"
    rm -rf "${work_dir}"
}

PrepareBuild(){
    # Set vars
    debroot="${work_dir}/deb"
    dataroot="${work_dir}/data"
    controlroot="${work_dir}/control"
    otherroot="${work_dir}/other"
    build_dir="${work_dir}/build"

    # Create work dir
    for _dir in "${work_dir}" "${debroot}" "${dataroot}" "${controlroot}" "${otherroot}" "${build_dir}"; do
        mkdir -p "${_dir}"
    done

    # Exit if notar = true
    if [[ "${notar}" = true ]]; then
        return 0
    fi

    # open deb file
    ar --output "${debroot}" -x "${debfile}"

    # debを展開して分類
    local _file _output _uncompressed=()
    while read -r _file; do
        _filename="$(basename "${_file}")"
        #if echo "${_filename}" | grep ".tar" > /dev/null 2>&1; then
        if [[ "$(file --mime-type "${_file}" 2> /dev/null | cut -d " " -f 2)" = "application/x-xz" ]]; then
            _uncompressed+=("${_file}")
            case "${_filename}" in
                "control."*)
                    _output="${controlroot}"
                    ;;
                "data."*)
                    _output="${dataroot}"
                    ;;
                *)
                    _output="${otherroot}"
                    ;;
            esac
            msg_info "tarアーカイブ ${_file} を見つけました"
            msg_info "${_filename} を展開しています ..."
            tar -x -f "${_file}" -C "${_output}"
        elif [[ "${_filename}" = "debian-binary" ]]; then
            msg_info "debian-binary を見つけました"
            msg_info "このファイルは情報を持たないため無視されます"
        else
            msg_info "ファイル ${_file} を見つけました"
            msg_warn "これは予期しないファイルのため無視されます"
            msg_info "${_filename} をコピーしています ..."
            cp "${_file}" "${otherroot}"
        fi
    done < <(find "${debroot}" -maxdepth 1 -mindepth 1 -type f -print0  | xargs -0 -I{} realpath {})

}

ParseControl(){
    control_file="${controlroot}/control"

    local _get
    _get(){
        local _value
        if ! printf "%s\n" "${skiplist[@]}" | grep -ix "${1}" > /dev/null 2>&1; then
            msg_debug "Parse ${1}"
            _value="$(cat "${control_file}" | grep -E "^${1}:" | sed "s|^${1}: ||g")"
            if [[ -v _value ]] && [[ ! "${_value}" = "" ]]; then
                echo -n "${_value}"
                return 0
            fi
        fi
        return 1
    }

    # pkgname
    if pkgbuiod_pkgname="$(_get "Package")"; then
        msg_debug "pkgname=\"${pkgbuiod_pkgname}\""
    fi

    # pkgver
    if pkgbuild_pkgver="$(_get "Version" | tr "-" "." )"; then
        msg_debug "pkgver=\"${pkgbuild_pkgver}\""
    fi

    # arch
    for _arch in $(_get "Architecture"); do
        case "${_arch}" in
            "amd64")
                pkgbuild_arch+=("x86_64")
                ;;
            "all")
                pkgbuild_arch=("any")
                ;;
            "i686" | "i386")
                pkgbuild_arch+=("${_arch}")
                ;;
        esac
    done
    msg_debug "arch=($(printf "\"%s\"" "${pkgbuild_arch[@]}"))"

    #Maintainer
    #maintainer="$(_get "Maintainer")"

    #Pre-Depends
    #predepends="$(_get "Pre-Depends")"

    #Depends
    _pacman="pacman"
    if which yay >/dev/null 2>&1; then
        msg_debug "Use yay instead of pacman"
        _pacman="yay"
    fi
    if printf "%s\n" "${skiplist[@]}" | grep "Depends" > /dev/null 2>&1; then
        msg_debug "Searching dependence package..."
    fi
    while read -r _pkg; do
        for __pkg in "${_pkg}" "$(printf "%s" "${_pkg}" | sed "s|lib||g")"; do
            if "${_pacman}" -Ssq "${__pkg}" 2> /dev/null | grep -x "${__pkg}" 1> /dev/null 2>&1; then
                pkgbuild_depends+=("${__pkg}")
                break
            fi
        done
    done < <(_get "Depends" | tr "," "\n" | cut -d " " -f 2 | tr -d "-" | tr -d "[0-9]" | tr -d ".")

    if (( "${#pkgbuild_depends[@]}" != 0 )); then
        msg_debug "depends=($(printf "\"%s\"" "${pkgbuild_depends[@]}"))"
    fi

    #Recommends
    if printf "%s\n" "${skiplist[@]}" | grep "Recommends" > /dev/null 2>&1; then
        msg_debug "Searching Recommends package..."
    fi
    while read -r _pkg; do
        for __pkg in "${_pkg}" "$(printf "%s" "${_pkg}" | sed "s|lib||g")"; do
            if "${_pacman}" -Ssq "${__pkg}" 2> /dev/null | grep -x "${__pkg}" 1> /dev/null 2>&1; then
                pkgbuild_optdepends+=("${__pkg}")
                break
            fi
        done
    done < <(_get "Recommends" | tr "," "\n" | cut -d " " -f 2 | tr -d "-" | tr -d "[0-9]" | tr -d ".")

    if (( "${#pkgbuild_optdepends[@]}" != 0 )); then
        msg_debug "optdepends=($(printf "\"%s\"" "${pkgbuild_optdepends[@]}"))"
    fi

    # Provides
    while read -r _pkg; do
        pkgbuild_provides+=("${_pkg}")
    done < <(_get "Provides")

    if (( "${#pkgbuild_provides[@]}" != 0 )); then
        msg_debug "provides=($(printf "\"%s\"" "${pkgbuild_provides[@]}"))"
    fi

    #Description
    if pkgbuild_pkgdesc="$(_get "Description")"; then
        msg_debug "pkgdesc=\"${pkgbuild_pkgdesc}\""
    fi

    #Homepage
    if pkgbuild_url="$(_get "Homepage")"; then
        msg_debug "url=\"${pkgbuild_url}\""
    fi
}

MakeInstallFile(){
    local _script _sourcefile _installfile="${build_dir}/${pkgbuiod_pkgname}.install"
    declare -A _pkgbuild_function=(
        ["preinst"]="pre_install"
        ["postinst"]="post_install"
        ["prerm"]="pre_remove"
        ["postrm"]="post_remove"
    )
    touch "${_installfile}"
    for _script in "preinst" "postinst" "prerm" "postrm"; do
        _sourcefile="${controlroot}/${_script}"
        if [[ -f "${_sourcefile}" ]]; then
            msg_debug "Found ${_script}"
            echo -e "function ${_pkgbuild_function["${_script}"]}(){" >> "${_installfile}"
            cat "${_sourcefile}" >> "${_installfile}"
            echo -e "}\n" >> "${_installfile}"
        fi
    done

}

MakeLocalPKGBUILD(){
    echo -n > "${build_dir}/PKGBUILD"

    local _write
    _write(){
        echo -e "${*}" >> "${build_dir}/PKGBUILD"
    }

    _write "# Maintainer : Yamada Hayao <hayao@fascode.net>"
    _write "_pkgname=\"${pkgbuiod_pkgname}\""
    _write "pkgname=\"${pkgbuiod_pkgname}-bin\""
    _write "pkgver=\"${pkgbuild_pkgver}\""
    _write "pkgrel=\"1\""
    _write "pkgdesc=\"${pkgbuild_pkgdesc}\""
    _write "url=\"${pkgbuild_url}\""
    _write 'install="${_pkgname}.install"'
    _write "arch=($(printf "\"%s\"" "${pkgbuild_arch[@]}"))"
    if (( "${#pkgbuild_depends[@]}" != 0 )); then
        _write "depends=($(printf "\"%s\"" "${pkgbuild_depends[@]}"))"
    fi
    if (( "${#pkgbuild_optdepends[@]}" != 0 )); then
        _write "optdepends=($(printf "\"%s\"" "${pkgbuild_optdepends[@]}"))"
    fi
    if (( "${#pkgbuild_provides[@]}" != 0 )); then
        _write "provides=($(printf "\"%s\"" "${pkgbuild_provides[@]}"))"
    fi
    _write "source=($(printf "\"%s\"" $(find "${debroot}" -maxdepth 1 -mindepth 1 -type f -name "data.tar.*" -printf "%f")))"
    _write 'md5sums=($(for i in "${source[@]}"; do echo "SKIP"; done))'
    _write 'noextract=("${source[@]}")'
    _write 'package() { find "${srcdir}" -name "*.tar*" -print0 | xargs -0 -I{} tar -x -v -f {} -C "${pkgdir}"; }'

    cp "${debroot}/data.tar"* "${build_dir}"

}

InstallPackage(){
    cd "${build_dir}"
    makepkg --clean --cleanbuild --install --skipchecksums --syncdeps --force
}

# Parse options
ARGUMENT=("${@}")
OPTS="w:hd"
OPTL="work:,help,debug,remove,notar,skip:"
if ! OPT=$(getopt -o ${OPTS} -l ${OPTL} -- ${DEFAULT_ARGUMENT} "${ARGUMENT[@]}"); then
    exit 1
fi

eval set -- "${OPT}"
msg_debug "Argument: ${OPT}"
unset OPT OPTS OPTL

while true; do
    case "${1}" in
        -d | --debug)
            debug=true
            shift 1
            ;;
        -h | --help)
            _usage
            exit 1
            ;;
        --remove)
            remove=true
            shift 1
            ;;
        --notar)
            notar=true
            shift 1
            ;;
        --skip)
            skiplist+=($(echo -n "${2}" | tr "," "\n"))
            echo "${skiplist[@]}"
            shift 2
            ;;
        --)
            shift 1
            break
            ;;
        *)
            msg_error "Invalid argument '${1}'"
            _usage
            exit 1
            ;;
    esac
done

debfile="${1}"
shift 1


Run CheckEnv
if [[ "${remove}" = true ]]; then
    Run RemoveWork
fi
Run PrepareBuild
Run ParseControl
Run MakeInstallFile
Run MakeLocalPKGBUILD
Run InstallPackage
